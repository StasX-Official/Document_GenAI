from datetime import datetime
from io import BytesIO
from pathlib import Path
from typing import Dict, List, Optional

import pandas as pd
from docx import Document
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.shared import Inches, Pt, RGBColor

try:
    from pptx import Presentation
    from pptx.util import Inches as PPTInches
    PPTX_AVAILABLE = True
except Exception:
    PPTX_AVAILABLE = False


class DocumentTemplate:
    def render_docx(self, doc: Document, content: str, metadata: Dict[str, str]) -> Document:
        for i in range(len(doc.paragraphs) - 1, -1, -1):
            paragraph = doc.paragraphs[i]
            paragraph._element.getparent().remove(paragraph._element)
        header = doc.add_heading(metadata.get("title", "AI Generated Document"), level=1)
        header.alignment = WD_ALIGN_PARAGRAPH.CENTER
        self._append_metadata_section(doc, metadata)
        doc.add_heading("Generated Content", level=2)
        for paragraph_text in content.split("\n\n"):
            if not paragraph_text.strip():
                continue
            paragraph = doc.add_paragraph()
            paragraph.paragraph_format.space_after = Pt(10)
            paragraph.paragraph_format.first_line_indent = Inches(0.25)
            paragraph.add_run(paragraph_text)
        doc.add_paragraph("").paragraph_format.space_before = Pt(16)
        footer = doc.add_paragraph(metadata.get("footer", "Generated by AI"))
        footer.alignment = WD_ALIGN_PARAGRAPH.CENTER
        footer_run = footer.runs[0]
        footer_run.font.size = Pt(9)
        footer_run.font.color.rgb = RGBColor(100, 100, 100)
        return doc

    def add_image(self, doc: Document, image_bytes: bytes, width_inches: float = 6.0, caption: Optional[str] = None) -> Document:
        stream = BytesIO(image_bytes)
        paragraph = doc.add_paragraph()
        run = paragraph.add_run()
        run.add_picture(stream, width=Inches(width_inches))
        if caption:
            caption_paragraph = doc.add_paragraph(caption)
            caption_paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
            caption_run = caption_paragraph.runs[0]
            caption_run.font.size = Pt(9)
            caption_run.italic = True
        return doc

    def add_table(self, doc: Document, data: List[List[str]], headers: Optional[List[str]] = None) -> Document:
        if headers:
            table = doc.add_table(rows=1, cols=len(headers))
            head = table.rows[0].cells
            for index, value in enumerate(headers):
                head[index].text = str(value)
        else:
            width = len(data[0]) if data else 0
            table = doc.add_table(rows=0, cols=width)
        for row in data:
            cells = table.add_row().cells
            for index, value in enumerate(row):
                cells[index].text = str(value)
        return doc

    def create_presentation(self, title: str, slides: List[dict]) -> Optional[bytes]:
        if not PPTX_AVAILABLE:
            return None
        presentation = Presentation()
        title_layout = presentation.slide_layouts[0]
        slide = presentation.slides.add_slide(title_layout)
        slide.shapes.title.text = title
        for data in slides:
            layout = presentation.slide_layouts[1] if data.get("content") else presentation.slide_layouts[5]
            slide = presentation.slides.add_slide(layout)
            if "title" in data:
                slide.shapes.title.text = data["title"]
            if data.get("content"):
                slide.shapes.placeholders[1].text = data["content"]
            if data.get("image"):
                stream = BytesIO(data["image"])
                slide.shapes.add_picture(stream, PPTInches(1), PPTInches(1), width=PPTInches(8))
        blob = BytesIO()
        presentation.save(blob)
        return blob.getvalue()

    def render_html(self, content: str, metadata: Dict[str, str]) -> str:
        timestamp = metadata.get("timestamp", datetime.utcnow().isoformat())
        prompt = metadata.get("prompt", "")
        model = metadata.get("model", "")
        body = "".join(f"<p>{paragraph}</p>" for paragraph in content.split("\n\n") if paragraph.strip())
        return (
            "<html><head><meta charset=\"utf-8\"><title>{title}</title></head>"
            "<body><h1>{title}</h1><section><h2>About</h2><p><strong>Generated on:</strong> {timestamp}</p>"
            "<p><strong>Model:</strong> {model}</p><p><strong>Prompt:</strong> {prompt}</p></section>"
            "<section><h2>Generated Content</h2>{body}</section>"
            "</body></html>"
        ).format(title=metadata.get("title", "AI Generated Document"), timestamp=timestamp, model=model, prompt=prompt, body=body)

    def render_markdown(self, content: str, metadata: Dict[str, str]) -> str:
        timestamp = metadata.get("timestamp", datetime.utcnow().isoformat())
        prompt = metadata.get("prompt", "")
        model = metadata.get("model", "")
        sections = [line.strip() for line in content.split("\n\n") if line.strip()]
        body = "\n\n".join(sections)
        return (
            f"# {metadata.get('title', 'AI Generated Document')}\n\n"
            f"**Generated on:** {timestamp}\n\n"
            f"**Model:** {model}\n\n"
            f"**Prompt:** {prompt}\n\n"
            f"## Generated Content\n\n{body}\n"
        )

    def render_plain(self, content: str, metadata: Dict[str, str]) -> str:
        timestamp = metadata.get("timestamp", datetime.utcnow().isoformat())
        model = metadata.get("model", "")
        prompt = metadata.get("prompt", "")
        header = f"{metadata.get('title', 'AI Generated Document')}\nGenerated on: {timestamp}\nModel: {model}\nPrompt: {prompt}\n"
        separator = "\n" + "=" * 40 + "\n"
        return header + separator + content

    def render_table_dataframe(self, dataframe: pd.DataFrame) -> Document:
        doc = Document()
        table = doc.add_table(rows=dataframe.shape[0] + 1, cols=dataframe.shape[1])
        for index, column in enumerate(dataframe.columns):
            table.cell(0, index).text = str(column)
        for row_index, (_, row) in enumerate(dataframe.iterrows(), start=1):
            for column_index, value in enumerate(row):
                table.cell(row_index, column_index).text = str(value)
        return doc

    def _append_metadata_section(self, doc: Document, metadata: Dict[str, str]) -> None:
        doc.add_heading("About this document", level=2)
        paragraph = doc.add_paragraph()
        paragraph.add_run("Generated on: ").bold = True
        paragraph.add_run(metadata.get("timestamp", datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")))
        paragraph.add_run("\nPrompt: ").bold = True
        prompt_run = paragraph.add_run(metadata.get("prompt", ""))
        prompt_run.italic = True
        paragraph.add_run("\nModel: ").bold = True
        paragraph.add_run(metadata.get("model", ""))